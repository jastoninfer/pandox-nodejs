{"title":"cf 712E Memory and Casinos","content":"题意：有一行 $n(n \\leq 100000)$ 个方格，从左往右第 $i$ 个方格的值为 $p_i(p_i = \\frac{a}{b}, 1 \\leq a < b \\leq 1e9)$ ，有两种操作，一种是将某个方格的值更新为另一个分数表示的有理数，另一种操作是寻味区间 $[l, r](l \\leq r)$ 的权值 $w(l, r)$ ； $w(l, r)$ 如下定义：\n\n方格在位置 $i$ 有 $p_i$ 的概率向右移动一格，有 $1-p_i$ 的概率向左移动一格。 $w(l, r)$ 表示方格初始位置在 $l$ 并且以在位置 $r$ 向右移动（下一个位置为 $r+1$ ）为终结，移动过程始终不超出区间范围的概率值。\n\n分析：对于任一区间 $[l, r]$ ，设 $f(i)$ 表示目前在位置 $i$ ，在移动合法的情况下到达终结状态的概率值。那么显然有 $f(i) = p_if(i + 1) + (1 - p_i)f(i - 1)$ ，注意边界情况是 $f(l - 1) = 0$ , 且 $f(r + 1) = 1$ ，我们设 $w(l, r) = f(l) = \\Delta$ ，那么可以得到递推关系 $f(r + 1) = 1 = g(r + 1) + f(r - 1)$ ，其中 $g(r + 1) = \\frac{\\prod_{i \\leq r - 1}(1 - p_i)}{\\prod_{i \\leq r}p_i} $ ，理论上我们可以用 $g(i)$ 前缀和得到任意区间的和，用线段树分别维护奇数位置和偶数位置即可。然而，由于 $g(i)$ 可能会非常大，以至于double存储失效，因此此方法并不可行。\n\n用分类统计的方法来解，考虑小规模问题与大规模问题之间的联系， $[l, r]$ 中间一任意位置为 $m$ ，讨论方格穿过 $m$ 的次数（等比求和），于是可以得到具有局部可累加性质的递推关系。用线段上进行点维护和区间查询即可。单次询问复杂度 $O(log(n))$ 。\n\n \n\ncode：\n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <assert.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mp std :: make_pair\n#define st first\n#define nd second\n#define keyn (root->ch[1]->ch[0])\n#define lson (u << 1)\n#define rson (u << 1 | 1)\n#define pii std :: pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define type(x) __typeof(x.begin())\n#define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n#define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n#define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n#define dbg(x) std::cout << x << std::endl\n#define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n#define clr(x, i) memset(x, (i), sizeof(x))\n#define maximize(x, y) x = max((x), (y))\n#define minimize(x, y) x = min((x), (y))\nusing namespace std;\ntypedef long long ll;\nconst int int_inf = 0x3f3f3f3f;\nconst ll ll_inf = 0x3f3f3f3f3f3f3f3f;\nconst int INT_INF = (int)((1ll << 31) - 1);\nconst double double_inf = 1e30;\nconst double eps = 1e-14;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ninline int readint() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\ninline int readstr(char *s) {\n    scanf(\"%s\", s);\n    return strlen(s);\n}\n\nclass cmpt {\npublic:\n    bool operator () (const int &x, const int &y) const {\n        return x > y;\n    }\n};\n\nint Rand(int x, int o) {\n    //if o set, return [1, x], else return [0, x - 1]\n    if (!x) return 0;\n    int tem = (int)((double)rand() / RAND_MAX * x) % x;\n    return o ? tem + 1 : tem;\n}\nll ll_rand(ll x, int o) {\n    if (!x) return 0;\n    ll tem = (ll)((double)rand() / RAND_MAX * x) % x;\n    return o ? tem + 1 : tem;\n}\n\nvoid data_gen() {\n    srand(time(0));\n    freopen(\"in.txt\", \"w\", stdout);\n    int kases = 1;\n    //printf(\"%d\\n\", kases);\n    while (kases--) {\n        ll sz = 1000;\n        printf(\"%d %d\\n\", sz, sz);\n        FOR(i, 1, sz) {\n            int x = Rand(1e2, 1);\n            int y = Rand(1e9, 1);\n            if (x > y) swap(x, y);\n            printf(\"%d %d\\n\", x, y);\n        }\n        FOR(i, 1, sz) {\n            int o = Rand(2, 0);\n            if (o) {\n                printf(\"1 \");\n                int pos = Rand(1000, 1);\n                int x = Rand(1e9, 1), y = Rand(1e9, 1);\n                if (x > y) swap(x, y);\n                printf(\"%d %d %d\\n\", pos, x, y);\n            } else {\n                printf(\"2 \");\n                int x = Rand(1000, 1), y = Rand(1e3, 1);\n                if (x > y) swap(x, y);\n                printf(\"%d %d\\n\", x, y);\n            }\n        }\n    }\n}\n\nconst int maxn = 1e5 + 10;\nstruct Seg {\n    double l1, l2, r1, r2;\n}seg[maxn << 2];\nint n, q;\npii a[maxn];\n\nvoid push_up(int u) {\n    seg[u].l2 = seg[lson].l2 * seg[rson].l2 / (1 - seg[lson].r1 * seg[rson].l1);\n    seg[u].l1 = seg[lson].l1 + seg[lson].l2 * seg[lson].r2 * seg[rson].l1 / (1 - seg[lson].r1 * seg[rson].l1);\n    seg[u].r1 = seg[rson].r1 + seg[rson].r2 * seg[rson].l2 * seg[lson].r1 / (1 - seg[lson].r1 * seg[rson].l1);\n    seg[u].r2 = seg[lson].r2 * seg[rson].r2 / (1 - seg[lson].r1 * seg[rson].l1);\n}\n\ndouble query1(int u, int l, int r, int L, int R);\ndouble query3(int u, int l, int r, int L, int R);\ndouble query4(int u, int l, int r, int L, int R);\n\ndouble query(int u, int l, int r, int L, int R) {\n    if (l == L && R == r) return seg[u].l2;\n    int mid = (l + r) >> 1;\n    if (R <= mid) return query(lson, l, mid, L, R);\n    else if (L >= mid) return query(rson, mid, r, L, R);\n    double lhs = query(lson, l, mid, L, mid), rhs = query(rson, mid, r, mid, R);\n    double L1 = query1(rson, mid, r, mid, R), R1 = query3(lson, l, mid, L, mid);\n    return lhs * rhs / (1. - L1 * R1);\n}\n\ndouble query3(int u, int l, int r, int L, int R) {\n    if (l == L && r == R) return seg[u].r1;\n    int mid = (l + r) >> 1;\n    if (R <= mid) return query3(lson, l, mid, L, R);\n    else if (L >= mid) return query3(rson, mid, r, L, R);\n    double tem = query3(rson, mid, r, mid, R);\n    double R2 = query4(rson, mid, r, mid, R);\n    double R1 = query3(lson, l, mid, L, mid);\n    double L2 = query(rson, mid, r, mid, R);\n    double L1 = query1(rson, mid, r, mid, R);\n    return tem + R2 * R1 * L2 / (1. - L1 * R1);\n}\n\ndouble query4(int u, int l, int r, int L, int R) {\n    if (l == L && r == R) return seg[u].r2;\n    int mid = (l + r) >> 1;\n    if (R <= mid) return query4(lson, l, mid, L, R);\n    else if (L >= mid) return query4(rson, mid, r, L, R);\n    double lhs = query4(lson, l, mid, L, mid) * query4(rson, mid, r, mid, R);\n    double rhs = query3(lson, l, mid, L, mid) * query3(rson, mid, r, mid, R);\n    return lhs / (1. - rhs);\n}\n\ndouble query1(int u, int l, int r, int L, int R) {\n    if (l == L && R == r) return seg[u].l1;\n    int mid = (l + r) >> 1;\n    if (R <= mid) return query1(lson, l, mid, L, R);\n    else if (L >= mid) return query1(rson, mid, r, L, R);\n    double tem = query1(lson, l, mid, L, mid);\n    double L1 = query1(rson, mid, r, mid, R);\n    double L2 = query(lson, l, mid, L, mid);\n    double R2 = query4(lson, l, mid, L, mid);\n    double R1 = query3(lson, l, mid, L, mid);\n    return tem + L2 * L1 * R2 / (1. - R1 * L1);\n}\n\nvoid build(int u, int l, int r) {\n    if (r - l < 2) {\n        double p = (double)a[l].first / a[l].nd;\n        seg[u].l1 = 1 - p;\n        seg[u].l2 = p;\n        seg[u].r1 = p;\n        seg[u].r2 = 1 - p;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(lson, l, mid), build(rson, mid, r);\n    push_up(u);\n}\n\nvoid update(int u, int l, int r, int L, int R, int lhs, int rhs) {\n    if (l == L && r == R) {\n        double p = (double)lhs / rhs;\n        seg[u].l1 = 1 - p;\n        seg[u].l2 = p;\n        seg[u].r1 = p;\n        seg[u].r2 = 1 - p;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (R <= mid) update(lson, l, mid, L, R, lhs, rhs);\n    else update(rson, mid, r, L, R, lhs, rhs);\n    push_up(u);\n}\n\ndouble __get(int x, int y) {\n    return query(1, 1, n + 1, x, y + 1);\n}\n\nvoid __set(int x, int y, int z) {\n    update(1, 1, n + 1, x, x + 1, y, z);\n}\n\nint main() {\n    //data_gen(); return 0;\n    //C(); return 0;\n    int debug = 0;\n    if (debug) freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    while (~scanf(\"%d%d\", &n, &q)) {\n        FOR(i, 1, n) scanf(\"%d%d\", &a[i].first, &a[i].nd);\n        build(1, 1, n + 1);\n        FOR(i, 1, q) {\n            int op, x, y, z;\n            scanf(\"%d%d%d\", &op, &x, &y);\n            if (op == 1) {\n                z = readint();\n                __set(x, y, z);\n            } else {\n                double ans = __get(x, y);\n                printf(\"%.10f\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}\n```","author":"pandoxone"}