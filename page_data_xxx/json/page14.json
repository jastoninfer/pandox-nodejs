{"title":"Problem Solving Strategy: Simplification of States","content":"状态精简是一类极其重要的方法，在动态规划、组合计数中的应用尤为普遍。先来看一些习题：\n\n1.LA 4380(CERC 2008) Counting Heaps\n\n题意：给出一颗 $n(1 \\leq n \\leq 500000)$ 个结点的有根树，要求给结点编号为 $1 \\sim n $ ，使得不同结点的标号不同，且每个非根结点标号比父节点小（满足堆性质）。求方案总数除以 $m$ 的余数 $(2 \\leq m \\leq 10^9)$ 。当 $n=5$ 时有如下 $8$ 种方案。\n分析：我们可以这样给结点分配编号：按照从小到大的顺序分配，最小的必然是树根，次小的分配给根的子结点中的某一个...。也就是给出一个满足父结点小于所有子树结点的一个拓扑序，那么维护一个下一次可以被分配为分配最小编号的结点队列，直到队列为空，初始状态只有根节点在队列中。这样遍历所有节点一次就找到了一个方案，方法可行但无效，复杂度太高。为什么？因为我们考虑得太细致了，把所有细节都兼顾的代价就是无法承受的复杂度，虽然方法对于答案是充分的，但是却并不必要。计数并不等同于枚举。更好的方法？深入挖掘问题的实质。实际上该问题是有局部性质的：我们固定每棵子树的所有结点编号的集合，那么总的方案数就是确定的，因为满足局部拓扑序必然不会破坏整体，而局部的相对顺序已经由子树的形态给出，我们不需要知道赋给每个结点的编号是具体是几，而只需要知道它是第几大。我们设 $f(i)$ 为根节点为 $i$ 的子树在所有候选编号集合固定的情况下的方案数，那么考虑 $i$ 的一个子节点 $j$ ，我们用 $g(u)$ 表示以 $u$ 为根结点子树的大小，那么 $j$ 子树的编号可取集合总数为 $\\textrm{C}_{g(i) - 1}^{g(j)}$ ，于是 $j$ 子树的总方案数为 $\\textrm{C}_{g(i) - 1}^{g(j)}f(j)$ ，这样剩下部分（将 $j$ 子树从 $i$ 子树中删去）的总方案数与当前 $j$ 子树的总方案数的乘积即为 $i$ 子树的总方案数。即有 $f(i)=f(j)\\textrm{C}_{g(i) - 1}^{g(j)}f(i\\setminus j)$ 其中 $f(i\\setminus g)$ 表示将 $j$ 子树从 $i$ 子树中删去得到的子树。我们设 $i$ 子树有 $p$ 个子结点，第 $i$ 个为 $n_i$ ，应用上式可以得到 $f(i)=\\prod_{j=1}^{p}{f(n_j)\\textrm{C}_{g(i)-1-\\sum_{k<p}{g(n_k)}}^{g(n_j)}}$ ，于是 $O(n)$ 时间即可解决。至此问题离通过还有一段距离，一方面还需要解决组合数对非素数取模（TLE/WA）的问题，另一方面注意栈溢出（RE），程序具体实现有兴趣可以参考下面的代码。\n\n代码：\n\n```cpp\n1 #include <algorithm>\n  2 #include <cstdio>\n  3 #include <cstring>\n  4 #include <string>\n  5 #include <queue>\n  6 #include <map>\n  7 #include <set>\n  8 #include <ctime>\n  9 #include <cmath>\n 10 #include <iostream>\n 11 #include <assert.h>\n 12 #define PI acos(-1.)\n 13 #pragma comment(linker, \"/STACK:102400000,102400000\")\n 14 #define max(a, b) ((a) > (b) ? (a) : (b))\n 15 #define min(a, b) ((a) < (b) ? (a) : (b))\n 16 #define mp std :: make_pair\n 17 #define st first\n 18 #define nd second\n 19 #define keyn (root->ch[1]->ch[0])\n 20 #define lson (u << 1)\n 21 #define rson (u << 1 | 1)\n 22 #define pii std :: pair<int, int>\n 23 #define pll pair<ll, ll>\n 24 #define pb push_back\n 25 #define type(x) __typeof(x.begin())\n 26 #define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n 27 #define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n 28 #define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n 29 #define dbg(x) std::cout << x << std::endl\n 30 #define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n 31 #define clr(x, i) memset(x, (i), sizeof(x))\n 32 #define maximize(x, y) x = max((x), (y))\n 33 #define minimize(x, y) x = min((x), (y))\n 34 //using namespace std;\n 35 typedef long long ll;\n 36 const int int_inf = 0x3f3f3f3f;\n 37 const ll ll_inf = 0x3f3f3f3f3f3f3f3f;\n 38 const int INT_INF = (int)((1ll << 31) - 1);\n 39 const double double_inf = 1e30;\n 40 const double eps = 1e-14;\n 41 typedef unsigned long long ul;\n 42 inline int readint(){\n 43     int x;\n 44     scanf(\"%d\", &x);\n 45     return x;\n 46 }\n 47 inline int readstr(char *s){\n 48     scanf(\"%s\", s);\n 49     return strlen(s);\n 50 }\n 51 //Here goes 2d geometry templates\n 52 struct Point{\n 53     double x, y;\n 54     Point(double x = 0, double y = 0) : x(x), y(y) {}\n 55 };\n 56 typedef Point Vector;\n 57 Vector operator + (Vector A, Vector B){\n 58     return Vector(A.x + B.x, A.y + B.y);\n 59 }\n 60 Vector operator - (Point A, Point B){\n 61     return Vector(A.x - B.x, A.y - B.y);\n 62 }\n 63 Vector operator * (Vector A, double p){\n 64     return Vector(A.x * p, A.y * p);\n 65 }\n 66 Vector operator / (Vector A, double p){\n 67     return Vector(A.x / p, A.y / p);\n 68 }\n 69 bool operator < (const Point& a, const Point& b){\n 70     return a.x < b.x || (a.x == b.x && a.y < b.y);\n 71 }\n 72 int dcmp(double x){\n 73     if(abs(x) < eps) return 0;\n 74     return x < 0 ? -1 : 1;\n 75 }\n 76 bool operator == (const Point& a, const Point& b){\n 77     return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0;\n 78 }\n 79 double Dot(Vector A, Vector B){\n 80     return A.x * B.x + A.y * B.y;\n 81 }\n 82 double Len(Vector A){\n 83     return sqrt(Dot(A, A));\n 84 }\n 85 double Angle(Vector A, Vector B){\n 86     return acos(Dot(A, B) / Len(A) / Len(B));\n 87 }\n 88 double Cross(Vector A, Vector B){\n 89     return A.x * B.y - A.y * B.x;\n 90 }\n 91 double Area2(Point A, Point B, Point C){\n 92     return Cross(B - A, C - A);\n 93 }\n 94 Vector Rotate(Vector A, double rad){\n 95     //rotate counterclockwise\n 96     return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));\n 97 }\n 98 Vector Normal(Vector A){\n 99     double L = Len(A);\n100     return Vector(-A.y / L, A.x / L);\n101 }\n102 void Normallize(Vector &A){\n103     double L = Len(A);\n104     A.x /= L, A.y /= L;\n105 }\n106 Point GetLineIntersection(Point P, Vector v, Point Q, Vector w){\n107     Vector u = P - Q;\n108     double t = Cross(w, u) / Cross(v, w);\n109     return P + v * t;\n110 }\n111 double DistanceToLine(Point P, Point A, Point B){\n112     Vector v1 = B - A, v2 = P - A;\n113     return abs(Cross(v1, v2)) / Len(v1);\n114 }\n115 double DistanceToSegment(Point P, Point A, Point B){\n116     if(A == B) return Len(P - A);\n117     Vector v1 = B - A, v2 = P - A, v3 = P - B;\n118     if(dcmp(Dot(v1, v2)) < 0) return Len(v2);\n119     else if(dcmp(Dot(v1, v3)) > 0) return Len(v3);\n120     else return abs(Cross(v1, v2)) / Len(v1);\n121 }\n122 Point GetLineProjection(Point P, Point A, Point B){\n123     Vector v = B - A;\n124     return A + v * (Dot(v, P - A) / Dot(v, v));\n125 }\n126 bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2){\n127     //Line1:(a1, a2) Line2:(b1,b2)\n128     double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n129            c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n130     return dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;\n131 }\n132 bool OnSegment(Point p, Point a1, Point a2){\n133     return dcmp(Cross(a1 - p, a2 - p)) == 0 && dcmp(Dot(a1 - p, a2 -p)) < 0;\n134 }\n135 Vector GetBisector(Vector v, Vector w){\n136     Normallize(v), Normallize(w);\n137     return Vector((v.x + w.x) / 2, (v.y + w.y) / 2);\n138 }\n139 \n140 bool OnLine(Point p, Point a1, Point a2){\n141     Vector v1 = p - a1, v2 = a2 - a1;\n142     double tem = Cross(v1, v2);\n143     return dcmp(tem) == 0;\n144 }\n145 struct Line{\n146     Point p;\n147     Vector v;\n148     Point point(double t){\n149         return Point(p.x + t * v.x, p.y + t * v.y);\n150     }\n151     Line(Point p, Vector v) : p(p), v(v) {}\n152 };\n153 struct Circle{\n154     Point c;\n155     double r;\n156     Circle(Point c, double r) : c(c), r(r) {}\n157     Circle(int x, int y, int _r){\n158         c = Point(x, y);\n159         r = _r;\n160     }\n161     Point point(double a){\n162         return Point(c.x + cos(a) * r, c.y + sin(a) * r);\n163     }\n164 };\n165 int GetLineCircleIntersection(Line L, Circle C, double &t1, double& t2, std :: vector<Point>& sol){\n166     double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;\n167     double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;\n168     double delta = f * f - 4 * e * g;\n169     if(dcmp(delta) < 0) return 0;\n170     if(dcmp(delta) == 0){\n171         t1 = t2 = -f / (2 * e); sol.pb(L.point(t1));\n172         return 1;\n173     }\n174     t1 = (-f - sqrt(delta)) / (2 * e); sol.pb(L.point(t1));\n175     t2 = (-f + sqrt(delta)) / (2 * e); sol.pb(L.point(t2));\n176     return 2;\n177 }\n178 double angle(Vector v){\n179     return atan2(v.y, v.x);\n180     //(-pi, pi]\n181 }\n182 int GetCircleCircleIntersection(Circle C1, Circle C2, std :: vector<Point>& sol){\n183     double d = Len(C1.c - C2.c);\n184     if(dcmp(d) == 0){\n185         if(dcmp(C1.r - C2.r) == 0) return -1; //two circle duplicates\n186         return 0; //two circles share identical center\n187     }\n188     if(dcmp(C1.r + C2.r - d) < 0) return 0; //too close\n189     if(dcmp(abs(C1.r - C2.r) - d) > 0) return 0; //too far away\n190     double a = angle(C2.c - C1.c); // angle of vector(C1, C2)\n191     double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d));\n192     Point p1 = C1.point(a - da), p2 = C1.point(a + da);\n193     sol.pb(p1);\n194     if(p1 == p2) return 1;\n195     sol.pb(p2);\n196     return 2;\n197 }\n198 int GetPointCircleTangents(Point p, Circle C, Vector* v){\n199     Vector u = C.c - p;\n200     double dist = Len(u);\n201     if(dist < C.r) return 0;//p is inside the circle, no tangents\n202     else if(dcmp(dist - C.r) == 0){\n203         // p is on the circles, one tangent only\n204         v[0] = Rotate(u, PI / 2);\n205         return 1;\n206     }else{\n207         double ang = asin(C.r / dist);\n208         v[0] = Rotate(u, -ang);\n209         v[1] = Rotate(u, +ang);\n210         return 2;\n211     }\n212 }\n213 int GetCircleCircleTangents(Circle A, Circle B, Point* a, Point* b){\n214     //a[i] store point of tangency on Circle A of tangent i\n215     //b[i] store point of tangency on Circle B of tangent i\n216     //six conditions is in consideration\n217     int cnt = 0;\n218     if(A.r < B.r) { std :: swap(A, B); std :: swap(a, b); }\n219     int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);\n220     int rdiff = A.r - B.r;\n221     int rsum = A.r + B.r;\n222     if(d2 < rdiff * rdiff) return 0; // one circle is inside the other\n223     double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);\n224     if(d2 == 0 && A.r == B.r) return -1; // two circle duplicates\n225     if(d2 == rdiff * rdiff){ // internal tangency\n226         a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++;\n227         return 1;\n228     }\n229     double ang = acos((A.r - B.r) / sqrt(d2));\n230     a[cnt] = A.point(base + ang); b[cnt++] = B.point(base + ang);\n231     a[cnt] = A.point(base - ang); b[cnt++] = B.point(base - ang);\n232     if(d2 == rsum * rsum){\n233         //one internal tangent\n234         a[cnt] = A.point(base);\n235         b[cnt++] = B.point(base + PI);\n236     }else if(d2 > rsum * rsum){\n237         //two internal tangents\n238         double ang = acos((A.r + B.r) / sqrt(d2));\n239         a[cnt] = A.point(base + ang); b[cnt++] = B.point(base + ang + PI);\n240         a[cnt] = A.point(base - ang); b[cnt++] = B.point(base - ang + PI);\n241     }\n242     return cnt;\n243 }\n244 Point ReadPoint(){\n245     double x, y;\n246     scanf(\"%lf%lf\", &x, &y);\n247     return Point(x, y);\n248 }\n249 Circle ReadCircle(){\n250     double x, y, r;\n251     scanf(\"%lf%lf%lf\", &x, &y, &r);\n252     return Circle(x, y, r);\n253 }\n254 //Here goes 3d geometry templates\n255 struct Point3{\n256     double x, y, z;\n257     Point3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}\n258 };\n259 typedef Point3 Vector3;\n260 Vector3 operator + (Vector3 A, Vector3 B){\n261     return Vector3(A.x + B.x, A.y + B.y, A.z + B.z);\n262 }\n263 Vector3 operator - (Vector3 A, Vector3 B){\n264     return Vector3(A.x - B.x, A.y - B.y, A.z - B.z);\n265 }\n266 Vector3 operator * (Vector3 A, double p){\n267     return Vector3(A.x * p, A.y * p, A.z * p);\n268 }\n269 Vector3 operator / (Vector3 A, double p){\n270     return Vector3(A.x / p, A.y / p, A.z / p);\n271 }\n272 double Dot3(Vector3 A, Vector3 B){\n273     return A.x * B.x + A.y * B.y + A.z * B.z;\n274 }\n275 double Len3(Vector3 A){\n276     return sqrt(Dot3(A, A));\n277 }\n278 double Angle3(Vector3 A, Vector3 B){\n279     return acos(Dot3(A, B) / Len3(A) / Len3(B));\n280 }\n281 double DistanceToPlane(const Point3& p, const Point3 &p0, const Vector3& n){\n282     return abs(Dot3(p - p0, n));\n283 }\n284 Point3 GetPlaneProjection(const Point3 &p, const Point3 &p0, const Vector3 &n){\n285     return p - n * Dot3(p - p0, n);\n286 }\n287 Point3 GetLinePlaneIntersection(Point3 p1, Point3 p2, Point3 p0, Vector3 n){\n288     Vector3 v = p2 - p1;\n289     double t = (Dot3(n, p0 - p1) / Dot3(n, p2 - p1));\n290     return p1 + v * t;//if t in range [0, 1], intersection on segment\n291 }\n292 Vector3 Cross(Vector3 A, Vector3 B){\n293     return Vector3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);\n294 }\n295 double Area3(Point3 A, Point3 B, Point3 C){\n296     return Len3(Cross(B - A, C - A));\n297 }\n298 class cmpt{\n299 public:\n300     bool operator () (const int &x, const int &y) const{\n301         return x > y;\n302     }\n303 };\n304 \n305 int Rand(int x, int o){\n306     //if o set, return [1, x], else return [0, x - 1]\n307     if(!x) return 0;\n308     int tem = (int)((double)rand() / RAND_MAX * x) % x;\n309     return o ? tem + 1 : tem;\n310 }\n311 ////////////////////////////////////////////////////////////////////////////////////\n312 ////////////////////////////////////////////////////////////////////////////////////\n313 void data_gen(){\n314     srand(time(0));\n315     freopen(\"in.txt\", \"w\", stdout);\n316     int kases = 250;\n317     printf(\"%d\\n\", kases);\n318     while(kases--){\n319         int sz = Rand(500000, 1);\n320         printf(\"%d %d\\n\", sz, Rand(1e9, 1) + 1);\n321         FOR(i, 2, sz){\n322             printf(\"%d\\n\", Rand(i - 1, 1));\n323         }\n324     }\n325 }\n326 \n327 struct cmpx{\n328     bool operator () (int x, int y) { return x > y; }\n329 };\n330 int debug = 1;\n331 int dx[] = {0, 0, 1, 1};\n332 int dy[] = {1, 0, 0, 1};\n333 //-------------------------------------------------------------------------\n334 const int maxn = 5e5 + 10;\n335 ll dp[maxn];\n336 ll mod;\n337 int n;\n338 std::vector<int> G[maxn];\n339 int sz[maxn];\n340 int prime[maxn], k;\n341 bool vis[maxn];\n342 void pre_init(){\n343     k = 0;\n344     prime[k++] = 2;\n345     clr(vis, 0);\n346     for(int i = 3; i < maxn; i += 2){\n347         if(vis[i]) continue;\n348         prime[k++] = i;\n349         for(int j = i; j < maxn; j += i) vis[j] = 1;\n350     }\n351 }\n352 int cnt[maxn][30];\n353 int p[maxn], pointer;\n354 ll fac[maxn];\n355 void init(){\n356     int tem = mod;\n357     int mid = (int)sqrt(mod + .5);\n358     pointer = 0;\n359     for(int i = 0; prime[i] <= mid; i++){\n360         if(tem % prime[i]) continue;\n361         p[pointer++] = prime[i];\n362         while(!(tem % prime[i])) tem /= prime[i];\n363         mid = (int)sqrt(tem + .5);\n364     }\n365     if(tem != 1) p[pointer++] = tem;\n366     clr(cnt, 0);\n367     FOR(i, 1, n){\n368         FOR(j, 0, pointer - 1) if(!(i % p[j])){\n369             int ti = i;\n370             while(!(ti % p[j])) ti /= p[j], ++cnt[i][j];\n371         }\n372     }\n373     FOR(i, 1, n) FOR(j, 0, pointer - 1) cnt[i][j] += cnt[i - 1][j];\n374     fac[0] = 1;\n375     FOR(i, 1, n){\n376         ll tem = i;\n377         FOR(j, 0, pointer - 1) while(tem % p[j] == 0) tem /= p[j];\n378         fac[i] = fac[i - 1] * tem % mod;\n379     }\n380 }\n381 \n382 ll power(ll a, ll p, ll mod){\n383     ll res = 1;\n384     a %= mod;\n385     while(p){\n386         if(p & 1) res = res * a % mod;\n387         p >>= 1;\n388         a = a * a % mod;\n389     }\n390     return res;\n391 }\n392 \n393 ll egcd(ll a, ll b, ll &x, ll &y){\n394     if(!b){\n395         x = 1, y = 0;\n396         return a;\n397     }else{\n398         ll r = egcd(b, a % b, y, x);\n399         y -= (a / b) * x;\n400         return r;\n401     }\n402 }\n403 int buf[30];\n404 ll cal(int n, int m){\n405     FOR(i, 0, pointer - 1) buf[i] = cnt[n][i] - cnt[n - m][i] - cnt[m][i];\n406     ll tem = 1;\n407     FOR(i, 0, pointer - 1){\n408         int num = buf[i];\n409         while(num--) tem = tem * p[i] % mod;\n410     }\n411     tem = tem * fac[n] % mod;\n412     ll x, y;\n413     egcd(fac[n - m], mod, x, y);\n414     tem = tem * ((x % mod + mod) % mod) % mod;\n415     egcd(fac[m], mod, x, y);\n416     tem = tem * ((x % mod + mod) % mod) % mod;\n417     return tem;\n418 }\n419 //360041529\n420 //-------------------------------------------------------------------------\n421 int main(){\n422     //data_gen(); return 0;\n423     //C(); return 0;\n424     debug = 0;\n425     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n426     if(debug) freopen(\"in.txt\", \"r\", stdin);\n427     //freopen(\"out.txt\", \"w\", stdout);\n428     pre_init();\n429     int T = readint();\n430     while(T--){\n431         scanf(\"%d%lld\", &n, &mod);\n432         init();\n433         FOR(i, 1, n) G[i].clear();\n434         FOR(i, 2, n){\n435             int x = readint();\n436             G[x].pb(i);\n437         }\n438         clr(sz, 0);\n439         ROF(i, n, 1){\n440             sz[i] = 1;\n441             int num = G[i].size();\n442             FOR(j, 0, num - 1) sz[i] += sz[G[i][j]];\n443             dp[i] = 1;\n444             int cur = sz[i] - 1;\n445             FOR(j, 0, num - 1){\n446                 int v = G[i][j];\n447                 dp[i] = dp[i] * dp[v] % mod * cal(cur, sz[v]) % mod;\n448                 cur -= sz[v];\n449             }\n450         }\n451         //dfs(1);\n452         printf(\"%lld\\n\", dp[1]);\n453     }\n454     //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n455     return 0;\n456 }\n\ncode：\n```","author":"pandoxone"}