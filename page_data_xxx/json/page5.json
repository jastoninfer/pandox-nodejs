{"title":"Graph Theory: The Shortest Path Problem","content":"- Dijkstra单源最短路径算法\nDijkstra可以计算出发点到每个点的最短路，及单源最短路径（SSSP）。这一特点使得Dijkstra常常用来进行其他算法的预处理。用Dijkstra算法计算最短路的代码如下：\n> 注：代码注释参见《算法竞赛入门经典——训练指南》（刘汝佳）\n```cpp\nstruct Dijkstra{\n    int n, m;\n    vector<E> e;\n    vector<int> G[maxn];\n    bool done[maxn];\n    int d[maxn];\n    int p[maxn];\n    void init(int n){\n        this->n = n;\n        FOR(i, 0, n - 1) G[i].clear();\n        e.clear();\n    }\n    void addE(int from, int to, int dist){\n        e.pb(E(from, to, dist));\n        m = e.size();\n        G[from].pb(m - 1);\n    }\n    void dijkstra(int s){\n        priority_queue<HeapNode> Q;\n        FOR(i, 0, n - 1) d[i] = int_inf;\n        d[s] = 0;\n        clr(done, 0);\n        Q.push(HeapNode(0, s));\n        while(!Q.empty()){\n            HeapNode x = Q.top(); Q.pop();\n            int u = x.u;\n            if(done[u]) continue;\n            done[u] = 1;\n            int sz = G[u].size();\n            FOR(i, 0, sz - 1){\n                E &y = e[G[u][i]];\n                if(d[y.to] > d[u] + y.dist){\n                    d[y.to] = d[u] + y.dist;\n                    p[y.to] = G[u][i];\n                    Q.push(HeapNode(d[y.to], y.to));\n                }\n            }\n        }\n    }\n};\n```\n- Bellman-Ford算法\nBellman-Ford算法的一个重要应用是判负圈。在迭代 $n−1$ \n次后如果还可以进行松弛（relax）操作，说明一定存在负圈。如果采用队列实现，那么当某个结点入队了 $n$ \n次时可以判断出存在负圈，代码如下：\n```cpp\nstruct Bellman_Ford{\n    int n, m;\n    vector<E> e;\n    vector<int> G[maxn];\n    bool inq[maxn];\n    int d[maxn];\n    int p[maxn];\n    int cnt[maxn];\n    void init(int n){\n        this->n = n;\n        FOR(i, 0, n - 1) G[i].clear();\n        e.clear();\n    }\n    void addE(int from, int to, int dist){\n        e.pb(E(from, to, dist));\n        m = e.size();\n        G[from].pb(m - 1);\n    }\n    bool negCyc(){\n        queue<int> Q;\n        clr(inq, 0), clr(cnt, 0);\n        FOR(i, 0, n - 1) d[i] = 0, inq[i] = 1, Q.push(i);\n        while(!Q.empty()){\n            int u = Q.front(); Q.pop();\n            inq[u] = 0;\n            int sz = G[u].size();\n            FOR(i, 0, sz - 1){\n                E &y = e[G[u][i]];\n                if(d[y.to] > d[u] + y.dist){\n                    d[y].to = d[u] + y.dist;\n                    p[e.to] = G[u][i];\n                    if(!inq[y.to]){\n                        Q.push(y.to);\n                        inq[y.to] = 1;\n                        if(++cnt[y.to] > n) return 1;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n```","author":"pandoxone"}