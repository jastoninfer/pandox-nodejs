{"title":"hdu 5751: Eades","content":"题意：对于整数序列 $A[1...n]$ 定义 $f(l, r)$ 为区间 $[l, r]$ 内等于区间最大值元素的个数，定义 $z[i]$ 为所有满足 $f(l, r)=i$ 的区间总数。对于所有的 $1 \\leq i \\leq n$ ，计算 $z[i]$ 。\n\n分析：考虑由大往小枚举最大值，对于某一最大值为 $M$ 的区间 $[l, r)$ ，满足 $a[p_i]=M$ 的元素将区间切割为若干子区间，那么这些子区间对长度的积对答案的某一项有等值的贡献，暴力枚举需要 $O(n^2)$ 的时间，整体考虑那些对答案某一项有贡献的子区间对的积，它们满足卷积的性质。因此只需将长度序列与其反序列作类似多项式乘法的fft，即可将时间优化为 $O(nlog(n))$ 。子区间递归处理即可。代码如下：\n\n```cpp\n#include <algorithm>\n  2 #include <cstdio>\n  3 #include <cstring>\n  4 #include <string>\n  5 #include <queue>\n  6 #include <map>\n  7 #include <set>\n  8 #include <stack>\n  9 #include <ctime>\n 10 #include <cmath>\n 11 #include <iostream>\n 12 #include <assert.h>\n 13 #pragma comment(linker, \"/STACK:102400000,102400000\")\n 14 #define max(a, b) ((a) > (b) ? (a) : (b))\n 15 #define min(a, b) ((a) < (b) ? (a) : (b))\n 16 #define mp std :: make_pair\n 17 #define st first\n 18 #define nd second\n 19 #define keyn (root->ch[1]->ch[0])\n 20 #define lson (u << 1)\n 21 #define rson (u << 1 | 1)\n 22 #define pii std :: pair<int, int>\n 23 #define pll pair<ll, ll>\n 24 #define pb push_back\n 25 #define type(x) __typeof(x.begin())\n 26 #define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n 27 #define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n 28 #define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n 29 #define dbg(x) std::cout << x << std::endl\n 30 #define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n 31 #define clr(x, i) memset(x, (i), sizeof(x))\n 32 #define maximize(x, y) x = max((x), (y))\n 33 #define minimize(x, y) x = min((x), (y))\n 34 using namespace std;\n 35 typedef long long ll;\n 36 const int int_inf = 0x3f3f3f3f;\n 37 const ll ll_inf = 0x3f3f3f3f3f3f3f3f;\n 38 const int INT_INF = (int)((1ll << 31) - 1);\n 39 const double double_inf = 1e30;\n 40 const double eps = 1e-14;\n 41 typedef unsigned long long ul;\n 42 typedef unsigned int ui;\n 43 inline int readint(){\n 44     int x;\n 45     scanf(\"%d\", &x);\n 46     return x;\n 47 }\n 48 inline int readstr(char *s){\n 49     scanf(\"%s\", s);\n 50     return strlen(s);\n 51 }\n 52 \n 53 class cmpt{\n 54 public:\n 55     bool operator () (const int &x, const int &y) const{\n 56         return x > y;\n 57     }\n 58 };\n 59 \n 60 int Rand(int x, int o){\n 61     //if o set, return [1, x], else return [0, x - 1]\n 62     if(!x) return 0;\n 63     int tem = (int)((double)rand() / RAND_MAX * x) % x;\n 64     return o ? tem + 1 : tem;\n 65 }\n 66 void data_gen(){\n 67     srand(time(0));\n 68     freopen(\"in.txt\", \"w\", stdout);\n 69     int kases = 20;\n 70     printf(\"%d\\n\", kases);\n 71     while(kases--){\n 72         int sz = 6e4;\n 73         printf(\"%d\\n\", sz);\n 74         FOR(i, 1, sz) printf(\"%d \", Rand(sz, 1));\n 75         printf(\"\\n\");\n 76     }\n 77 }\n 78 \n 79 struct cmpx{\n 80     bool operator () (int x, int y) { return x > y; }\n 81 };\n 82 const int maxn = 6e4 + 10;\n 83 int a[maxn];\n 84 int n;\n 85 struct Seg{\n 86     int l, r, v;\n 87 }seg[maxn << 2];\n 88 void build(int u, int l, int r){\n 89     seg[u].l = l, seg[u].r = r;\n 90     if(seg[u].r - seg[u].l < 2){\n 91         seg[u].v = l;\n 92         return;\n 93     }\n 94     int mid = (l + r) >> 1;\n 95     build(lson, l, mid), build(rson, mid, r);\n 96     if(a[seg[rson].v] > a[seg[lson].v]) seg[u].v = seg[rson].v;\n 97     else seg[u].v = seg[lson].v;\n 98 }\n 99 int query(int u, int l, int r){\n100     if(seg[u].l == l && seg[u].r == r) return seg[u].v;\n101     int mid = (seg[u].l + seg[u].r) >> 1;\n102     if(r <= mid) return query(lson, l, r);\n103     else if(l >= mid) return query(rson, l, r);\n104     int lhs = query(lson, l, mid), rhs = query(rson, mid, r);\n105     if(a[rhs] > a[lhs]) return rhs;\n106     return lhs;\n107 }\n108 int maxi;\n109 vector<int> pos[maxn];\n110 int idx[maxn];\n111 void init(){\n112     maxi = -1;\n113     FOR(i, 1, n) maximize(maxi, a[i]);\n114     FOR(i, 1, maxi) pos[i].clear();\n115     FOR(i, 1, n){\n116         int sz = pos[a[i]].size();\n117         idx[i] = sz;\n118         pos[a[i]].pb(i);\n119     }\n120 }\n121 ll z[maxn];\n122 ll c[maxn], d[maxn], e[maxn << 1];\n123 int k;\n124 const double PI = 2 * asin(1.);\n125 struct Complex{\n126     double x, y;\n127     Complex(double x = 0, double y = 0) : x(x), y(y) {}\n128 };\n129 Complex operator + (const Complex &lhs, const Complex &rhs){\n130     return Complex(lhs.x + rhs.x, lhs.y + rhs.y);\n131 }\n132 Complex operator - (const Complex &lhs, const Complex &rhs){\n133     return Complex(lhs.x - rhs.x, lhs.y - rhs.y);\n134 }\n135 Complex operator * (const Complex &lhs, const Complex &rhs){\n136     double tl = lhs.x * rhs.x, tr = lhs.y * rhs.y, tt = (lhs.x + lhs.y) * (rhs.x + rhs.y);\n137     return Complex(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);\n138 }\n139 Complex w[2][maxn << 2], x[maxn << 2], y[maxn << 2];\n140 \n141 void fft(Complex x[], int k, int v){\n142     int i, j, l;\n143     Complex tem;\n144     for(i = j = 0; i < k; i++){\n145         if(i > j) tem = x[i], x[i] = x[j], x[j] = tem;\n146         for(l = k >> 1; (j ^= l) < l; l >>= 1) ;\n147     }\n148     for(i = 2; i <= k; i <<= 1) for(j = 0; j < k; j += i) for(l = 0; l < i >> 1; l++){\n149         tem = x[j + l + (i >> 1)] * w[v][k / i * l];\n150         x[j + l + (i >> 1)] = x[j + l] - tem;\n151         x[j + l] = x[j + l] + tem;\n152     }\n153 }\n154 int tot;\n155 void solve(int l, int r){\n156     if(l >= r) return;\n157     if(r - l == 1){\n158         ++z[1];\n159         return;\n160     }\n161     int p = query(1, l, r);\n162     int tem = idx[p];\n163     int sz = pos[a[p]].size();\n164     k = 0;\n165     c[k++] = p - l + 1;\n166     while(tem  + 1 < sz && pos[a[p]][tem + 1] < r) c[k++] = pos[a[p]][tem + 1] - pos[a[p]][tem], ++tem;\n167     c[k++] = r - pos[a[p]][tem];\n168     ROF(i, k - 1, 0) d[i] = c[k - 1 - i];\n169     int len;\n170     for(len = 1; len < (k << 1); len <<= 1) ;\n171     FOR(i, 0, len) w[1][len - i] = w[0][i] = Complex(cos(PI * 2 * i / len), sin(PI * 2 * i / len));\n172     FOR(i, 0, k - 1) x[i] = Complex(c[i], 0);\n173     FOR(i, k, len - 1) x[i] = Complex(0, 0);\n174     fft(x, len, 0);\n175     FOR(i, 0, k - 1) y[i] = Complex(d[i], 0);\n176     FOR(i, k, len - 1) y[i] = Complex(0, 0);\n177     fft(y, len, 0);\n178     FOR(i, 0, len - 1) x[i] = x[i] * y[i];\n179     fft(x, len, 1);\n180     FOR(i, 0, 2 * k - 2) e[i] = (ll)(x[i].x / len + .5);\n181     FOR(i, 0, k - 2) z[k - 1 - i] += e[i];\n182     tem = idx[p];\n183     solve(l, p);\n184     while(tem + 1 < sz && pos[a[p]][tem + 1] < r) solve(pos[a[p]][tem] + 1, pos[a[p]][tem + 1]), ++tem;\n185     solve(pos[a[p]][tem] + 1, r);\n186 }\n187 int main(){\n188     //data_gen(); return 0;\n189     //C(); return 0;\n190     int debug = 0;\n191     if(debug) freopen(\"in.txt\", \"r\", stdin);\n192     //freopen(\"out.txt\", \"w\", stdout);\n193     int T = readint();\n194     while(T--){\n195         n = readint();\n196         FOR(i, 1, n) a[i] = readint();\n197         build(1, 1, n + 1);\n198         init();\n199         clr(z, 0);\n200         tot = 0;\n201         solve(1, n + 1);\n202         ll ans = 0;\n203         FOR(i, 1, n) ans += z[i] ^ i;\n204         printf(\"%lld\\n\", ans);\n205     }\n206     return 0;\n207 }\n```","author":"pandoxone"}