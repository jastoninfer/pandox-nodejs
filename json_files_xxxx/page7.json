{"title":"hdu 5780 gcd","content":"题意：给定 $x, n$ 满足 $1 \\leq x, n \\leq 1000000$ ，求 $\\sum{(x^a-1,x^b-1)}$ 对 $1e9+7$ 取模后的值，其中 $1 \\leq a, b \\leq n$ 。\n\n分析：首先不难有 $(x^a - 1, x ^ b - 1) = x^{(a,b)}-1$ （证明方法可沿欧几里得定理思路），那么我们只需要考虑 $(a,b) = d$ 即可，设 $f(d)$ 为使得 $(a, b) = d$ 的对数，那么不难有 $ans = \\sum_{d = 1}^{n}{f(d)(x^d-1)}$ 。下面考虑计算 $f(d)$ ，由于 $(a, b) = d$ 满足 $d \\mid a, d \\mid b, (\\frac{a}{d}, \\frac{b}{d}) = 1$ ，于是对于满足 $1\\leq a \\leq b \\leq n$ 的序对 $(a, b)$ ，其总数为 $\\sum_{i=1}^{\\frac{n}{d}}{\\varphi(i)}$ ，因为我们可以在互质的对上乘以系数 $d$ 使其映射到对 $(a, b)$ 。那么对于题目中的要求，总数为 $2\\sum_{i=1}^{\\frac{n}{d}}{\\varphi(i)}-1$ ，那么我们就只用到了欧拉函数的前缀和，注意到 $f(d)$ 只与 $\\frac{n}{d}$ 有关，而右边可以使用等比求和，于是可以分段计算，每段对应的 $\\frac{n}{d}$ 固定。那么这样做预处理是 $O(n)$ 的，每次询问的复杂度是 $O(\\sqrt{n})$ 的。代码如下：\n\n```cpp\n1 #include <algorithm>\n  2 #include <cstdio>\n  3 #include <cstring>\n  4 #include <string>\n  5 #include <queue>\n  6 #include <map>\n  7 #include <set>\n  8 #include <stack>\n  9 #include <ctime>\n 10 #include <cmath>\n 11 #include <iostream>\n 12 #include <assert.h>\n 13 #define PI acos(-1.)\n 14 #pragma comment(linker, \"/STACK:102400000,102400000\")\n 15 #define max(a, b) ((a) > (b) ? (a) : (b))\n 16 #define min(a, b) ((a) < (b) ? (a) : (b))\n 17 #define mp std :: make_pair\n 18 #define st first\n 19 #define nd second\n 20 #define keyn (root->ch[1]->ch[0])\n 21 #define lson (u << 1)\n 22 #define rson (u << 1 | 1)\n 23 #define pii std :: pair<int, int>\n 24 #define pll pair<ll, ll>\n 25 #define pb push_back\n 26 #define type(x) __typeof(x.begin())\n 27 #define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n 28 #define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n 29 #define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n 30 #define dbg(x) std::cout << x << std::endl\n 31 #define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n 32 #define clr(x, i) memset(x, (i), sizeof(x))\n 33 #define maximize(x, y) x = max((x), (y))\n 34 #define minimize(x, y) x = min((x), (y))\n 35 using namespace std;\n 36 typedef long long ll;\n 37 const int int_inf = 0x3f3f3f3f;\n 38 const ll ll_inf = 0x3f3f3f3f3f3f3f3f;\n 39 const int INT_INF = (int)((1ll << 31) - 1);\n 40 const double double_inf = 1e30;\n 41 const double eps = 1e-14;\n 42 typedef unsigned long long ul;\n 43 typedef unsigned int ui;\n 44 inline int readint(){\n 45     int x;\n 46     scanf(\"%d\", &x);\n 47     return x;\n 48 }\n 49 inline int readstr(char *s){\n 50     scanf(\"%s\", s);\n 51     return strlen(s);\n 52 }\n 53 //Here goes 2d geometry templates\n 54 struct Point{\n 55     double x, y;\n 56     Point(double x = 0, double y = 0) : x(x), y(y) {}\n 57 };\n 58 typedef Point Vector;\n 59 Vector operator + (Vector A, Vector B){\n 60     return Vector(A.x + B.x, A.y + B.y);\n 61 }\n 62 Vector operator - (Point A, Point B){\n 63     return Vector(A.x - B.x, A.y - B.y);\n 64 }\n 65 Vector operator * (Vector A, double p){\n 66     return Vector(A.x * p, A.y * p);\n 67 }\n 68 Vector operator / (Vector A, double p){\n 69     return Vector(A.x / p, A.y / p);\n 70 }\n 71 bool operator < (const Point& a, const Point& b){\n 72     return a.x < b.x || (a.x == b.x && a.y < b.y);\n 73 }\n 74 int dcmp(double x){\n 75     if(abs(x) < eps) return 0;\n 76     return x < 0 ? -1 : 1;\n 77 }\n 78 bool operator == (const Point& a, const Point& b){\n 79     return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0;\n 80 }\n 81 double Dot(Vector A, Vector B){\n 82     return A.x * B.x + A.y * B.y;\n 83 }\n 84 double Len(Vector A){\n 85     return sqrt(Dot(A, A));\n 86 }\n 87 double Angle(Vector A, Vector B){\n 88     return acos(Dot(A, B) / Len(A) / Len(B));\n 89 }\n 90 double Cross(Vector A, Vector B){\n 91     return A.x * B.y - A.y * B.x;\n 92 }\n 93 double Area2(Point A, Point B, Point C){\n 94     return Cross(B - A, C - A);\n 95 }\n 96 Vector Rotate(Vector A, double rad){\n 97     //rotate counterclockwise\n 98     return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));\n 99 }\n100 Vector Normal(Vector A){\n101     double L = Len(A);\n102     return Vector(-A.y / L, A.x / L);\n103 }\n104 void Normallize(Vector &A){\n105     double L = Len(A);\n106     A.x /= L, A.y /= L;\n107 }\n108 Point GetLineIntersection(Point P, Vector v, Point Q, Vector w){\n109     Vector u = P - Q;\n110     double t = Cross(w, u) / Cross(v, w);\n111     return P + v * t;\n112 }\n113 double DistanceToLine(Point P, Point A, Point B){\n114     Vector v1 = B - A, v2 = P - A;\n115     return abs(Cross(v1, v2)) / Len(v1);\n116 }\n117 double DistanceToSegment(Point P, Point A, Point B){\n118     if(A == B) return Len(P - A);\n119     Vector v1 = B - A, v2 = P - A, v3 = P - B;\n120     if(dcmp(Dot(v1, v2)) < 0) return Len(v2);\n121     else if(dcmp(Dot(v1, v3)) > 0) return Len(v3);\n122     else return abs(Cross(v1, v2)) / Len(v1);\n123 }\n124 Point GetLineProjection(Point P, Point A, Point B){\n125     Vector v = B - A;\n126     return A + v * (Dot(v, P - A) / Dot(v, v));\n127 }\n128 bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2){\n129     //Line1:(a1, a2) Line2:(b1,b2)\n130     double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n131            c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n132     return dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;\n133 }\n134 bool OnSegment(Point p, Point a1, Point a2){\n135     return dcmp(Cross(a1 - p, a2 - p)) == 0 && dcmp(Dot(a1 - p, a2 -p)) < 0;\n136 }\n137 Vector GetBisector(Vector v, Vector w){\n138     Normallize(v), Normallize(w);\n139     return Vector((v.x + w.x) / 2, (v.y + w.y) / 2);\n140 }\n141 \n142 bool OnLine(Point p, Point a1, Point a2){\n143     Vector v1 = p - a1, v2 = a2 - a1;\n144     double tem = Cross(v1, v2);\n145     return dcmp(tem) == 0;\n146 }\n147 struct Line{\n148     Point p;\n149     Vector v;\n150     Point point(double t){\n151         return Point(p.x + t * v.x, p.y + t * v.y);\n152     }\n153     Line(Point p, Vector v) : p(p), v(v) {}\n154 };\n155 struct Circle{\n156     Point c;\n157     double r;\n158     Circle(Point c, double r) : c(c), r(r) {}\n159     Circle(int x, int y, int _r){\n160         c = Point(x, y);\n161         r = _r;\n162     }\n163     Point point(double a){\n164         return Point(c.x + cos(a) * r, c.y + sin(a) * r);\n165     }\n166 };\n167 int GetLineCircleIntersection(Line L, Circle C, double &t1, double& t2, std :: vector<Point>& sol){\n168     double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;\n169     double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;\n170     double delta = f * f - 4 * e * g;\n171     if(dcmp(delta) < 0) return 0;\n172     if(dcmp(delta) == 0){\n173         t1 = t2 = -f / (2 * e); sol.pb(L.point(t1));\n174         return 1;\n175     }\n176     t1 = (-f - sqrt(delta)) / (2 * e); sol.pb(L.point(t1));\n177     t2 = (-f + sqrt(delta)) / (2 * e); sol.pb(L.point(t2));\n178     return 2;\n179 }\n180 double angle(Vector v){\n181     return atan2(v.y, v.x);\n182     //(-pi, pi]\n183 }\n184 int GetCircleCircleIntersection(Circle C1, Circle C2, std :: vector<Point>& sol){\n185     double d = Len(C1.c - C2.c);\n186     if(dcmp(d) == 0){\n187         if(dcmp(C1.r - C2.r) == 0) return -1; //two circle duplicates\n188         return 0; //two circles share identical center\n189     }\n190     if(dcmp(C1.r + C2.r - d) < 0) return 0; //too close\n191     if(dcmp(abs(C1.r - C2.r) - d) > 0) return 0; //too far away\n192     double a = angle(C2.c - C1.c); // angle of vector(C1, C2)\n193     double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d));\n194     Point p1 = C1.point(a - da), p2 = C1.point(a + da);\n195     sol.pb(p1);\n196     if(p1 == p2) return 1;\n197     sol.pb(p2);\n198     return 2;\n199 }\n200 int GetPointCircleTangents(Point p, Circle C, Vector* v){\n201     Vector u = C.c - p;\n202     double dist = Len(u);\n203     if(dist < C.r) return 0;//p is inside the circle, no tangents\n204     else if(dcmp(dist - C.r) == 0){\n205         // p is on the circles, one tangent only\n206         v[0] = Rotate(u, PI / 2);\n207         return 1;\n208     }else{\n209         double ang = asin(C.r / dist);\n210         v[0] = Rotate(u, -ang);\n211         v[1] = Rotate(u, +ang);\n212         return 2;\n213     }\n214 }\n215 int GetCircleCircleTangents(Circle A, Circle B, Point* a, Point* b){\n216     //a[i] store point of tangency on Circle A of tangent i\n217     //b[i] store point of tangency on Circle B of tangent i\n218     //six conditions is in consideration\n219     int cnt = 0;\n220     if(A.r < B.r) { std :: swap(A, B); std :: swap(a, b); }\n221     int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);\n222     int rdiff = A.r - B.r;\n223     int rsum = A.r + B.r;\n224     if(d2 < rdiff * rdiff) return 0; // one circle is inside the other\n225     double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);\n226     if(d2 == 0 && A.r == B.r) return -1; // two circle duplicates\n227     if(d2 == rdiff * rdiff){ // internal tangency\n228         a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++;\n229         return 1;\n230     }\n231     double ang = acos((A.r - B.r) / sqrt(d2));\n232     a[cnt] = A.point(base + ang); b[cnt++] = B.point(base + ang);\n233     a[cnt] = A.point(base - ang); b[cnt++] = B.point(base - ang);\n234     if(d2 == rsum * rsum){\n235         //one internal tangent\n236         a[cnt] = A.point(base);\n237         b[cnt++] = B.point(base + PI);\n238     }else if(d2 > rsum * rsum){\n239         //two internal tangents\n240         double ang = acos((A.r + B.r) / sqrt(d2));\n241         a[cnt] = A.point(base + ang); b[cnt++] = B.point(base + ang + PI);\n242         a[cnt] = A.point(base - ang); b[cnt++] = B.point(base - ang + PI);\n243     }\n244     return cnt;\n245 }\n246 Point ReadPoint(){\n247     double x, y;\n248     scanf(\"%lf%lf\", &x, &y);\n249     return Point(x, y);\n250 }\n251 Circle ReadCircle(){\n252     double x, y, r;\n253     scanf(\"%lf%lf%lf\", &x, &y, &r);\n254     return Circle(x, y, r);\n255 }\n256 //Here goes 3d geometry templates\n257 struct Point3{\n258     double x, y, z;\n259     Point3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}\n260 };\n261 typedef Point3 Vector3;\n262 Vector3 operator + (Vector3 A, Vector3 B){\n263     return Vector3(A.x + B.x, A.y + B.y, A.z + B.z);\n264 }\n265 Vector3 operator - (Vector3 A, Vector3 B){\n266     return Vector3(A.x - B.x, A.y - B.y, A.z - B.z);\n267 }\n268 Vector3 operator * (Vector3 A, double p){\n269     return Vector3(A.x * p, A.y * p, A.z * p);\n270 }\n271 Vector3 operator / (Vector3 A, double p){\n272     return Vector3(A.x / p, A.y / p, A.z / p);\n273 }\n274 double Dot3(Vector3 A, Vector3 B){\n275     return A.x * B.x + A.y * B.y + A.z * B.z;\n276 }\n277 double Len3(Vector3 A){\n278     return sqrt(Dot3(A, A));\n279 }\n280 double Angle3(Vector3 A, Vector3 B){\n281     return acos(Dot3(A, B) / Len3(A) / Len3(B));\n282 }\n283 double DistanceToPlane(const Point3& p, const Point3 &p0, const Vector3& n){\n284     return abs(Dot3(p - p0, n));\n285 }\n286 Point3 GetPlaneProjection(const Point3 &p, const Point3 &p0, const Vector3 &n){\n287     return p - n * Dot3(p - p0, n);\n288 }\n289 Point3 GetLinePlaneIntersection(Point3 p1, Point3 p2, Point3 p0, Vector3 n){\n290     Vector3 v = p2 - p1;\n291     double t = (Dot3(n, p0 - p1) / Dot3(n, p2 - p1));\n292     return p1 + v * t;//if t in range [0, 1], intersection on segment\n293 }\n294 Vector3 Cross(Vector3 A, Vector3 B){\n295     return Vector3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);\n296 }\n297 double Area3(Point3 A, Point3 B, Point3 C){\n298     return Len3(Cross(B - A, C - A));\n299 }\n300 class cmpt{\n301 public:\n302     bool operator () (const int &x, const int &y) const{\n303         return x > y;\n304     }\n305 };\n306 \n307 int Rand(int x, int o){\n308     //if o set, return [1, x], else return [0, x - 1]\n309     if(!x) return 0;\n310     int tem = (int)((double)rand() / RAND_MAX * x) % x;\n311     return o ? tem + 1 : tem;\n312 }\n313 void data_gen(){\n314     srand(time(0));\n315     freopen(\"in.txt\", \"w\", stdout);\n316     int kases = 10;\n317     printf(\"%d\\n\", kases);\n318     while(kases--){\n319         int sz = 2e4;\n320         int m = 1e5;\n321         printf(\"%d %d\\n\", sz, m);\n322         FOR(i, 1, sz) printf(\"%d \", Rand(100, 1));\n323         printf(\"\\n\");\n324         FOR(i, 1, sz) printf(\"%d \", Rand(1e9, 1));\n325         printf(\"\\n\");\n326         FOR(i, 1, m){\n327             int l = Rand(sz, 1);\n328             int r = Rand(sz, 1);\n329             int c = Rand(1e9, 1);\n330             printf(\"%d %d %d %d\\n\", l, r, c, Rand(100, 1));\n331         }\n332     }\n333 }\n334 \n335 struct cmpx{\n336     bool operator () (int x, int y) { return x > y; }\n337 };\n338 const int mod = 1e9 + 7;\n339 const int maxn = 1e6 + 10;\n340 ll phi[maxn];\n341 void init_miu(){\n342     clr(phi, 0);\n343     phi[1] = 1;\n344     FOR(i, 2, maxn - 1) if(!phi[i]){\n345         for(int j = i; j < maxn; j += i){\n346             if(!phi[j]) phi[j] = j;\n347             phi[j] = phi[j] / i * (i - 1);\n348         }\n349     }\n350     FOR(i, 1, maxn - 1) phi[i] = (phi[i] + phi[i - 1]) % mod;\n351 }\n352 ll power(ll a, ll p, ll mod){\n353     ll res = 1;\n354     a %= mod;\n355     while(p){\n356         if(p & 1) res = res * a % mod;\n357         p >>= 1;\n358         a = a * a % mod;\n359     }\n360     return res;\n361 }\n362 \n363 ll cal2(int x, int n){\n364     ll ans = 0;\n365     int p = 1;\n366     while(p <= n){\n367         int np = n / (n / p);\n368         int delta = np - p + 1;\n369         ll cnt = (2 * phi[n / p] + mod - 1) % mod;\n370         ll lhs = 0;\n371         if(x > 1){\n372             lhs = power(x, p, mod) * (power(x, delta, mod) + mod - 1) % mod;\n373             lhs = lhs * power(x - 1, mod - 2, mod) % mod;\n374             lhs = (lhs - delta + mod) % mod;\n375         }\n376         ans = (ans + lhs * cnt % mod) % mod;\n377         p = np + 1;\n378     }\n379     return ans;\n380 }\n381 int main(){\n382     //data_gen(); return 0;\n383     //C(); return 0;\n384     int debug = 0;\n385     if(debug) freopen(\"in.txt\", \"r\", stdin);\n386     //freopen(\"out.txt\", \"w\", stdout);\n387     init_miu();\n388     int T = readint();\n389     while(T--){\n390         int x = readint(), n = readint();\n391         printf(\"%lld\\n\", cal2(x, n));\n392     }\n393     return 0;\n394 }\n\ncode：\n```\n 当然本题我用莫比乌斯反演也勉强通过了（用了900多ms，仅仅通过了1次），使用了两次分段求和，每次询问的复杂度介于 $O(\\sqrt{n})$ 与 $O(n)$ 之间。虽然不是正解，仍然可以看出欧拉函数与莫比乌斯函数之间关系相通。","author":"pandoxone"}