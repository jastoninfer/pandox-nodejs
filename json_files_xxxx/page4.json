{"title":"图论: 2-SAT问题","content":"2-SAT问题是这样的：有  $n$ 个布尔变量  $x_i$ ，另有  $m$ 个需要满足的条件，每个条件的形式都是“  $x_i$ 为真/假或者  $x_j$ 为真/假”。比如：\"  $x_1$ 为真或者  $x_3$ 为假“。注意这里的”或“是指两个条件至少有一个是正确的，比如  $x_1$ 和  $x_3$ 一共有  $3$ 中组合满足\"  $x_1$ 为真或者  $x_3$ 为假“。2-SAT问题的目标是给每个变量赋值，使得所有条件得到满足。求解2-SAT问题一般比较常见方法是构造一张有向图  $G$ ，其中每个变量  $x_i$ 拆成两个结点  $2i$ 和  $2i+1$ ，分别表示  $x_i$ 为假和  $x_i$ 为真。最后要为每个变量选择其中一个结点标记。比如，若标记了节点  $2i$ ，表示  $x_i$ 为假；如果标记了  $2i+1$ ，表示  $x_i$ 为真。对于“  $x_i$ 为假或者  $x_j$ 为假”这样的条件，我们连一条有向边  $2i+1 \\rightarrow 2j$ ，表示如果标记节点  $2i+1$ 那么也必须标记结点  $j$ ，同理还需要连一条有向边  $2j+1 \\rightarrow 2i$ 。对于其他情况，也可以类似连边。换句话说，每个条件对应两条“对称”的边。接下来逐一考虑每个没有赋值的变量，设为  $x_i$ 。我们首先假定它为假，然后标记借点  $2_i$ ，并且沿着有向边标记所有能标记的结点。如果标记过程中发现某个变量对应的两个结点都被标记，则“  $x_i$ 为假”这个假定不成立，需要改成“  $x_i$ 为真”，然后重新标记。注意，该算法无回溯过程。如果当前考虑的变量不管赋值为真还是假都会引起矛盾，可以证明整个2-SAT问题无解（即使调整以前赋值的变量也没用）。这是很显然的，每个变量只会影响到关系到该变量的表达式的取值，因此对于未赋值的变量一定与之前的赋值无关，可以分开考虑，整个问题有解需要满足每个块都有解。下面给出求解2-SAT问题的代码：\n```cpp\nstruct _2_sat{\n    int n;\n    vector<int> G[maxn << 1];\n    bool mark[maxn << 1];\n    int S[maxn << 1], c;\n    bool dfs(int x){\n        if(mark[x ^ 1]) return 0;\n        if(mark[x]) return 1;\n        mark[x] = 1;\n        S[c++] = x;\n        FOR(i, 0, G[x].size() - 1) if(!dfs(G[x][i])) return 0;\n        return 1;\n    }\n    void init(int n){\n        this->n = n;\n        FOR(i, 0, 2 * n - 1) G[i].clear();\n        clr(mark, 0);\n    }\n    //x = xval or y = yval\n    void add_caluse(int x, int xval, int y, int yval){\n        x = x * 2 + xval, y = y * 2 + yval;\n        G[x ^ 1].pb(y), G[y ^ 1].pb(x);\n    }\n    bool solve(){\n        for(int i = 0; i < 2 * n; i += 2) if(!mark[i] && !mark[i + 1]){\n            c = 0;\n            if(!dfs(i)){\n                while(c > 0) mark[S[--c]] = 0;\n                if(!dfs(i + 1)) return 0;\n            }\n        }\n        return 1;\n    }\n};\n```\n相关习题：\n\nLA 3713 Astronauts\n\n```cpp\n1 #include <algorithm>\n  2 #include <cstdio>\n  3 #include <cstring>\n  4 #include <string>\n  5 #include <queue>\n  6 #include <map>\n  7 #include <set>\n  8 #include <stack>\n  9 #include <ctime>\n 10 #include <cmath>\n 11 #include <iostream>\n 12 #include <assert.h>\n 13 #pragma comment(linker, \"/STACK:102400000,102400000\")\n 14 #define max(a, b) ((a) > (b) ? (a) : (b))\n 15 #define min(a, b) ((a) < (b) ? (a) : (b))\n 16 #define mp std :: make_pair\n 17 #define st first\n 18 #define nd second\n 19 #define keyn (root->ch[1]->ch[0])\n 20 #define lson (u << 1)\n 21 #define rson (u << 1 | 1)\n 22 #define pii std :: pair<int, int>\n 23 #define pll pair<ll, ll>\n 24 #define pb push_back\n 25 #define type(x) __typeof(x.begin())\n 26 #define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n 27 #define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n 28 #define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n 29 #define dbg(x) std::cout << x << std::endl\n 30 #define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n 31 #define clr(x, i) memset(x, (i), sizeof(x))\n 32 #define maximize(x, y) x = max((x), (y))\n 33 #define minimize(x, y) x = min((x), (y))\n 34 using namespace std;\n 35 typedef long long ll;\n 36 const int int_inf = 0x3f3f3f3f;\n 37 const ll ll_inf = 0x3f3f3f3f3f3f3f3f;\n 38 const int INT_INF = (int)((1ll << 31) - 1);\n 39 const double double_inf = 1e30;\n 40 const double eps = 1e-14;\n 41 typedef unsigned long long ul;\n 42 typedef unsigned int ui;\n 43 inline int readint(){\n 44     int x;\n 45     scanf(\"%d\", &x);\n 46     return x;\n 47 }\n 48 inline int readstr(char *s){\n 49     scanf(\"%s\", s);\n 50     return strlen(s);\n 51 }\n 52 \n 53 class cmpt{\n 54 public:\n 55     bool operator () (const int &x, const int &y) const{\n 56         return x > y;\n 57     }\n 58 };\n 59 \n 60 int Rand(int x, int o){\n 61     //if o set, return [1, x], else return [0, x - 1]\n 62     if(!x) return 0;\n 63     int tem = (int)((double)rand() / RAND_MAX * x) % x;\n 64     return o ? tem + 1 : tem;\n 65 }\n 66 ll ll_rand(ll x, int o){\n 67     if(!x) return 0;\n 68     ll tem = (ll)((double)rand() / RAND_MAX * x) % x;\n 69     return o ? tem + 1 : tem;\n 70 }\n 71 \n 72 void data_gen(){\n 73     srand(time(0));\n 74     freopen(\"in.txt\", \"w\", stdout);\n 75     int kases = 10;\n 76     printf(\"%d\\n\", kases);\n 77     while(kases--){\n 78         ll sz = 100000;\n 79         printf(\"%d\\n\", sz);\n 80         FOR(i, 1, sz){\n 81             int o = Rand(2, 0);\n 82             int x = Rand(1e9, 1);\n 83             int y1 = Rand(1e9, 1), y2 = Rand(1e9, 1);\n 84             if(o == 0) printf(\"%d %d %d %d\\n\", x, y1, x, y1);\n 85             else printf(\"%d %d %d %d\\n\", y1, x, y2, x);\n 86         }\n 87     }\n 88 }\n 89 const int maxn = 1e5 + 10;\n 90 int n, m;\n 91 ll sum;\n 92 int id[maxn];\n 93 int age[maxn];\n 94 int head[maxn << 1];\n 95 struct E{\n 96     int to, nex;\n 97 }e[maxn << 2];\n 98 bool vis[maxn << 1];\n 99 int N;\n100 void addE(int x, int y){\n101     e[N].nex = head[x];\n102     e[N].to = y;\n103     head[x] = N++;\n104 }\n105 int stk[maxn], k;\n106 bool dfs(int u){\n107     if(vis[u]) return 1;\n108     vis[u] = 1;\n109     stk[k++] = u;\n110     if(vis[u] && vis[u ^ 1]) return 0;\n111     for(int i = head[u]; ~i; i = e[i].nex){\n112         int v = e[i].to;\n113         if(!dfs(v)) return 0;\n114     }\n115     return 1;\n116 }\n117 \n118 bool solve(int u){\n119     k = 0;\n120     if(dfs(2 * u)) return 1;\n121     while(k) vis[stk[--k]] = 0;\n122     if(dfs(2 * u + 1)) return 1;\n123     return 0;\n124 }\n125 \n126 int main(){\n127     //data_gen(); return 0;\n128     //C(); return 0;\n129     int debug = 0;\n130     if(debug) freopen(\"in.txt\", \"r\", stdin);\n131     //freopen(\"out.txt\", \"w\", stdout);\n132     while(~scanf(\"%d%d\", &n, &m) && n){\n133         sum = 0;\n134         FOR(i, 0, n - 1) age[i] = readint(), sum += age[i];\n135         FOR(i, 0, n - 1) id[i] = (ll)age[i] * n >= sum ? 0 : 1;\n136         clr(head, -1), N = 0;\n137         FOR(i, 0, m - 1){\n138             int x = readint() - 1, y = readint() - 1;\n139             //cc[i][0] = x, cc[i][1] = y;\n140             addE(2 * x, 2 * y + 1);\n141             if(id[x] == id[y]) addE(2 * x + 1, 2 * y);\n142             addE(2 * y, 2 * x + 1);\n143             if(id[x] == id[y]) addE(2 * y + 1, 2 * x);\n144         }\n145         int ok = 1;\n146         clr(vis, 0);\n147         FOR(i, 0, n - 1) if(!vis[2 * i] && !vis[2 * i + 1] && !solve(i)){\n148             ok = 0;\n149             break;\n150         }\n151         if(!ok) puts(\"No solution.\");\n152         else FOR(i, 0, n - 1) putchar(!vis[2 * i + 1] ? 'C' : 'A' + id[i]), putchar('\\n');\n153         //int res = verdict();\n154         //printf(\"verdict :: %s\", res ? \"ok\\n\" : \"err\\n\");\n155     }\n156     return 0;\n157 }\n\ncode:\n```\n","author":"pandoxone"}