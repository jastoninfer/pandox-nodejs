{"title":"hdu 5901 Count primes","content":"题意：\n\n计数区间 $[1, n](1 \\leq n \\leq 10^{11})$ 素数个数。\n\n分析：\n\n这里只介绍一种动态规划的做法。\n\n首先要说一下【分层思想】在动态规划中非常重要，下面的做法也正是基于这一思想。\n\n我们用 $dp[i]$ 表示区间 $[1, \\frac{n}{i}]$ 中素数的个数，用 $c[i]$ 表示区间 $[1, i]$ 中素数个数。\n\n那么我们要求的即是 $dp[1]$ 。由于 $n$ 最大是 $10^{11}$ ，因此任何区间内合数的最小素因子不超过 $\\sqrt{10^{11}}$ 。为了筛选素数，只需从区间内全体整数逐步划去最小素因子分别为 $2, 3, 5, ...,$ 的和数即可。因此我们首先从小到大枚举素数 $i$ 。\n\n把 $dp[i]$ 和这样的一个集合对应起来：当枚举到素数 $i$ 时， $dp[i]$ 对应集合 $DP(i)$ ， $DP(i)$ 是区间 $[1, \\frac{n}{i}]$ 划去所有包含不超过 $i$ 的素因子的数后得到的集合， $dp[i]$ 为集合 $DP(i)$ 的阶（长度）。考虑在加入素数 $i$ 后更新 $dp[j]$ ：\n\n $dp[j] := dp[j] - (dp[i * j] - c[i - 1]) (*)$ \n\n 注意到 $DP(i * j)$ 和 $DP(j)$ 的前面一部分是相同的， $DP(i * j)$ 即区间 $[1, \\frac{n}{i * j}]$ 经划去所有包含小于 $i$ 素因子合数后得到的集合，它当然包含所有小于 $i$ 的素数。因此\n\n $dp[i * j] - c[i - 1]$ 中恰好包含了我们更新 $dp[j]$ 时全部需要划去的元素，注意一点，这里 $dp[i * j]$ 与 $c[n / i / j]$ 与 $c[n / (i * j)]$ 是等效的（因为 $j$ 在内层循环逐增时，当且仅当 $(i * j) | n$ 时对应到整数位置）。\n\n因为我们枚举最小素因子 $i$ ，同时保证 $n / i / j \\geq i - 1$ 因此控制外层循环 $i \\leq \\sqrt{n} AND n / i / j \\geq i - 1$ \n\n对于内层循环 $j$ ，仅仅更新那些以后会用到的，这里保证在用到式  $(*)$ 时， $i * j \\leq \\sqrt{n}$ ， 因此 $j \\leq \\sqrt{n}$ \n\n当 $i * j > \\sqrt{n}$ 时，使用式 $dp[j] := dp[j] - (c[n / i / j] - c[i - 1])$ 替换上面的状态转移方程。\n\n为此可以保证 $dp[]$ 和 $c[]$ 空间均为 $O(\\sqrt{n})$ 。\n\n再考虑对 $c[]$ 的更新：\n\n $c[j] := c[j] - (c[j / i] - c[i - 1]) \\text{ case }j / i \\geq i - 1$ \n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <functional>\n#include <cmath>\n#include <iostream>\n#include <assert.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mp std :: make_pair\n#define st first\n#define nd second\n#define keyn (root->ch[1]->ch[0])\n#define lson (u << 1)\n#define rson (u << 1 | 1)\n#define pii std :: pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define type(x) __typeof(x.begin())\n#define foreach(i, j) for(type(j)i = j.begin(); i != j.end(); i++)\n#define FOR(i, s, t) for(int i = (s); i <= (t); i++)\n#define ROF(i, t, s) for(int i = (t); i >= (s); i--)\n#define dbg(x) std::cout << x << std::endl\n#define dbg2(x, y) std::cout << x << \" \" << y << std::endl\n#define clr(x, i) memset(x, (i), sizeof(x))\n#define maximize(x, y) x = max((x), (y))\n#define minimize(x, y) x = min((x), (y))\nusing namespace std;\ntypedef long long ll;\nconst int int_inf = 0x3f3f3f3f;\nconst ll ll_inf = 0x3f3f3f3f3f3f3f3f;\nconst int INT_INF = (int)((1ll << 31) - 1);\nconst double double_inf = 1e30;\nconst double eps = 1e-14;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ninline int readint() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\ninline int readstr(char *s) {\n    scanf(\"%s\", s);\n    return strlen(s);\n}\n\nclass cmpt {\npublic:\n    bool operator () (const int &x, const int &y) const {\n        return x > y;\n    }\n};\n\nint Rand(int x, int o) {\n    //if o set, return [1, x], else return [0, x - 1]\n    if (!x) return 0;\n    int tem = (int)((double)rand() / RAND_MAX * x) % x;\n    return o ? tem + 1 : tem;\n}\nll ll_rand(ll x, int o) {\n    if (!x) return 0;\n    ll tem = (ll)((double)rand() / RAND_MAX * x) % x;\n    return o ? tem + 1 : tem;\n}\n\nvoid data_gen() {\n    srand(time(0));\n    freopen(\"in.txt\", \"w\", stdout);\n    int kases = 1;\n    //printf(\"%d\\n\", kases);\n    while (kases--) {\n        ll sz = 100000;\n        printf(\"%d\\n\", sz);\n        FOR(i, 1, sz) {\n            int o = Rand(2, 0);\n            int O = Rand(26, 0);\n            putchar(O + (o ? 'a' : 'A'));\n        }\n        putchar('\\n');\n    }\n}\n\nconst int maxn = 4e5 + 10;\nint c[maxn];\nll dp[maxn];\nll n;\n\nll solve() {\n    int mid = (int)sqrt(n + .5);\n    FOR(i, 1, mid) dp[i] = n / i - 1, c[i] = i - 1;\n    for (int i = 2; i <= mid; i++) {\n        if (c[i] == c[i - 1]) continue;\n        for (int j = 1; j <= mid && n / i / j >= i - 1; j++) {\n            if (j <= mid / i) dp[j] -= dp[i * j] - c[i - 1];\n            else dp[j] -= c[n / i / j] - c[i - 1];\n        }\n        ROF(j, mid, 1) {\n            if (j / i < i - 1) break;\n            c[j] -= c[j / i] - c[i - 1];\n        }\n    }\n    return dp[1];\n}\n\nint main() {\n    //data_gen(); return 0;\n    //C(); return 0;\n    int debug = 0;\n    if (debug) freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    while (~scanf(\"%lld\", &n)) {\n        ll ans = solve();\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```","author":"pandoxone"}